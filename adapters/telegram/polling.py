"""
Telegram polling worker for RAG backend.
"""

from __future__ import annotations

import sys
from pathlib import Path

# Add the project root to Python path
project_root = Path(__file__).parent.parent.parent
sys.path.insert(0, str(project_root))

import time
import requests
from loguru import logger
from typing import Optional
from app.config import CONFIG
from app.utils import write_debug_event
from adapters.telegram_adapter import render_html, split_for_telegram, send as send_html


BOT_TOKEN = CONFIG.telegram_bot_token
POLL_INTERVAL = CONFIG.telegram_poll_interval
API_URL = f"https://api.telegram.org/bot{BOT_TOKEN}"


def create_feedback_keyboard(interaction_id: str) -> dict:
    """Build inline keyboard for simple feedback."""
    return {
        "inline_keyboard": [
            [
                {"text": "üëç", "callback_data": f"feedback_positive_{interaction_id}"},
                {"text": "üëé", "callback_data": f"feedback_negative_{interaction_id}"},
            ]
        ]
    }


def extract_interaction_id(callback_data: str) -> Optional[str]:
    """Extract interaction ID from callback payload."""
    prefixes = ("feedback_positive_", "feedback_negative_")
    for prefix in prefixes:
        if callback_data.startswith(prefix):
            suffix = callback_data[len(prefix):]
            return suffix or None
    return None


def handle_callback_query(callback_query: dict) -> None:
    """Process callback buttons (used for feedback)."""
    try:
        callback_data = callback_query.get("data", "")
        chat_id = callback_query.get("message", {}).get("chat", {}).get("id")

        if not callback_data or not chat_id:
            return

        if callback_data.startswith("feedback_"):
            feedback_type = "positive" if callback_data.startswith("feedback_positive_") else "negative"
            interaction_id = extract_interaction_id(callback_data)
            if not interaction_id:
                logger.warning(f"Callback without interaction_id: {callback_data!r}")
                return

            try:
                requests.post(
                    f"{CONFIG.api_base_url}/v1/admin/quality/feedback",
                    json={
                        "interaction_id": interaction_id,
                        "feedback_type": feedback_type,
                        "chat_id": chat_id,
                    },
                    timeout=30,
                )
            except Exception as e:
                logger.error(f"Error recording feedback: {e}")

            # Acknowledge callback to Telegram
            try:
                requests.post(
                    f"{API_URL}/answerCallbackQuery",
                    json={
                        "callback_query_id": callback_query.get("id"),
                        "text": "–°–ø–∞—Å–∏–±–æ, —É—á—Ç—ë–º –≤–∞—à –æ—Ç–∑—ã–≤!",
                    },
                    timeout=10,
                )
            except Exception as e:
                logger.error(f"Error answering callback query: {e}")

    except Exception as e:
        logger.error(f"Error handling callback query: {e}")


def send_telegram_message(chat_id: str, answer_data: dict) -> None:
    """Send a formatted message to Telegram using HTML render pipeline."""
    try:
        answer_markdown = (
            answer_data.get("answer_markdown")
            or answer_data.get("answer")
            or ""
        )
        sources = answer_data.get("sources", []) or []
        interaction_id = answer_data.get("interaction_id", "") or ""
        reply_markup = answer_data.get("reply_markup")

        html_text = render_html(answer_markdown, sources)
        parts = split_for_telegram(html_text)

        if interaction_id and not reply_markup:
            reply_markup = create_feedback_keyboard(interaction_id)

        send_html(chat_id, parts, reply_markup=reply_markup)

    except Exception as e:
        logger.error(f"Error sending Telegram message: {e}")


def handle_message(message: dict) -> None:
    """Process an incoming Telegram message and call RAG API."""
    try:
        chat_id = message.get("chat", {}).get("id")
        text = (message.get("text") or "").strip()

        if not chat_id or not text:
            return

        write_debug_event(
            "telegram_message_received",
            {"chat_id": chat_id, "text_length": len(text), "timestamp": time.time()},
        )

        try:
            response = requests.post(
                f"{CONFIG.api_base_url}/v1/chat/query",
                json={
                    "message": text,
                    "channel": "telegram",
                    "chat_id": chat_id,
                },
                timeout=120,
            )

            if response.status_code == 200:
                answer_data = response.json()
                send_telegram_message(str(chat_id), answer_data)

                write_debug_event(
                    "telegram_message_sent",
                    {
                        "chat_id": chat_id,
                        "answer_length": len(answer_data.get("answer", "")),
                        "sources_count": len(answer_data.get("sources", [])),
                        "timestamp": time.time(),
                    },
                )
            else:
                logger.error(
                    f"RAG API error: {response.status_code} - {response.text}"
                )
                send_telegram_message(
                    str(chat_id),
                    {
                        "answer": "–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.",
                        "sources": [],
                    },
                )
        except Exception as e:
            logger.error(f"Error calling RAG API: {e}")
            send_telegram_message(
                str(chat_id),
                {
                    "answer": "–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.",
                    "sources": [],
                },
            )
    except Exception as e:
        logger.error(f"Error handling message: {e}")


def delete_webhook() -> bool:
    """
    –£–¥–∞–ª—è–µ—Ç webhook –∏ –æ—á–∏—â–∞–µ—Ç pending updates.

    Returns:
        True –µ—Å–ª–∏ webhook —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª—ë–Ω
    """
    try:
        resp = requests.post(
            f"{API_URL}/deleteWebhook",
            json={"drop_pending_updates": True},
            timeout=10
        )
        if resp.status_code == 200:
            data = resp.json()
            if data.get("ok"):
                logger.info("‚úÖ Webhook successfully deleted")
                return True
        logger.error(f"Failed to delete webhook: {resp.status_code} - {resp.text}")
        return False
    except Exception as e:
        logger.error(f"Error deleting webhook: {e}")
        return False


def handle_409_conflict() -> bool:
    """
    –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –æ—à–∏–±–∫—É 409 (Conflict).

    –û—à–∏–±–∫–∞ 409 –≤–æ–∑–Ω–∏–∫–∞–µ—Ç –∫–æ–≥–¥–∞:
    - –ù–µ—Å–∫–æ–ª—å–∫–æ —ç–∫–∑–µ–º–ø–ª—è—Ä–æ–≤ –±–æ—Ç–∞ –∏—Å–ø–æ–ª—å–∑—É—é—Ç long polling –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ
    - –£ –±–æ—Ç–∞ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω webhook
    - –ü—Ä–µ–¥—ã–¥—É—â–∏–π –ø—Ä–æ—Ü–µ—Å—Å –±–æ—Ç–∞ –Ω–µ –∑–∞–≤–µ—Ä—à–∏–ª—Å—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ

    Returns:
        True –µ—Å–ª–∏ –ø—Ä–æ–±–ª–µ–º–∞ —Ä–µ—à–µ–Ω–∞
    """
    logger.warning("‚ö†Ô∏è –û–±–Ω–∞—Ä—É–∂–µ–Ω–∞ –æ—à–∏–±–∫–∞ 409 (Conflict)")
    logger.info("–ü–æ–ø—ã—Ç–∫–∞ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è: —É–¥–∞–ª–µ–Ω–∏–µ webhook...")

    if delete_webhook():
        logger.info("‚úÖ Webhook —É–¥–∞–ª—ë–Ω, –æ–∂–∏–¥–∞–Ω–∏–µ 2 —Å–µ–∫—É–Ω–¥—ã...")
        time.sleep(2)
        return True

    logger.error("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å webhook")
    logger.error("–í–æ–∑–º–æ–∂–Ω—ã–µ –ø—Ä–∏—á–∏–Ω—ã:")
    logger.error("  - –î—Ä—É–≥–æ–π —ç–∫–∑–µ–º–ø–ª—è—Ä –±–æ—Ç–∞ –≤—Å—ë –µ—â—ë –∑–∞–ø—É—â–µ–Ω")
    logger.error("  - –ë–æ—Ç –∑–∞–ø—É—â–µ–Ω –≤ Docker/Kubernetes")
    logger.error("–ü–æ–¥–æ–∂–¥–∏—Ç–µ 1-2 –º–∏–Ω—É—Ç—ã –∏ –ø–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç–µ –±–æ—Ç–∞")
    return False


def get_updates(offset: int | None = None) -> list:
    """Fetch updates from Telegram API (long polling)."""
    try:
        params = {"timeout": 30, "offset": offset}
        resp = requests.get(f"{API_URL}/getUpdates", params=params, timeout=40)

        if resp.status_code == 200:
            data = resp.json()
            if data.get("ok"):
                return data.get("result", [])
            logger.error(f"Telegram API error: {data}")
            return []

        if resp.status_code == 409:
            # –ö–æ–Ω—Ñ–ª–∏–∫—Ç: –ø—ã—Ç–∞–µ–º—Å—è –∏—Å–ø—Ä–∞–≤–∏—Ç—å
            if handle_409_conflict():
                # –ü–æ–≤—Ç–æ—Ä–Ω–∞—è –ø–æ–ø—ã—Ç–∫–∞ –ø–æ—Å–ª–µ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è
                logger.info("–ü–æ–≤—Ç–æ—Ä–Ω–∞—è –ø–æ–ø—ã—Ç–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è updates...")
                resp = requests.get(f"{API_URL}/getUpdates", params=params, timeout=40)
                if resp.status_code == 200:
                    data = resp.json()
                    if data.get("ok"):
                        return data.get("result", [])
            return []

        logger.error(f"Failed to get updates: {resp.status_code}")
        return []
    except Exception as e:
        logger.error(f"Error getting updates: {e}")
        return []


def verify_bot_ready() -> bool:
    """
    –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç—å –±–æ—Ç–∞ –∫ –∑–∞–ø—É—Å–∫—É.

    –£–¥–∞–ª—è–µ—Ç webhook –µ—Å–ª–∏ –æ–Ω —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –∏ –ø—Ä–æ–≤–µ—Ä—è–µ—Ç –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å API.

    Returns:
        True –µ—Å–ª–∏ –±–æ—Ç –≥–æ—Ç–æ–≤ –∫ –∑–∞–ø—É—Å–∫—É
    """
    try:
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç–∞—Ç—É—Å –±–æ—Ç–∞
        resp = requests.get(f"{API_URL}/getMe", timeout=10)
        if resp.status_code != 200:
            logger.error(f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –±–æ—Ç–µ: {resp.status_code}")
            return False

        data = resp.json()
        if not data.get("ok"):
            logger.error(f"‚ùå API –≤–µ—Ä–Ω—É–ª –æ—à–∏–±–∫—É: {data}")
            return False

        bot_info = data.get("result", {})
        logger.info(f"‚úÖ –ë–æ—Ç –∞–∫—Ç–∏–≤–µ–Ω: @{bot_info.get('username', 'unknown')}")

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º webhook
        resp = requests.get(f"{API_URL}/getWebhookInfo", timeout=10)
        if resp.status_code == 200:
            data = resp.json()
            if data.get("ok"):
                webhook_info = data.get("result", {})
                webhook_url = webhook_info.get("url", "")

                if webhook_url:
                    logger.warning(f"‚ö†Ô∏è –û–±–Ω–∞—Ä—É–∂–µ–Ω webhook: {webhook_url}")
                    logger.info("–£–¥–∞–ª–µ–Ω–∏–µ webhook –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è polling...")
                    if not delete_webhook():
                        logger.error("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å webhook")
                        return False
                else:
                    logger.info("‚úÖ Webhook –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")

        return True

    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç–∏ –±–æ—Ç–∞: {e}")
        return False


def run_polling_loop() -> None:
    """Main polling loop."""
    logger.info("Starting Telegram polling loop...")
    logger.info(f"Bot token: {BOT_TOKEN[:10]}...")
    logger.info(f"API base: {CONFIG.api_base_url}")
    logger.info(f"Poll interval: {POLL_INTERVAL}s")

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç—å –±–æ—Ç–∞ –ø–µ—Ä–µ–¥ –∑–∞–ø—É—Å–∫–æ–º
    logger.info("\n" + "=" * 60)
    logger.info("–ü—Ä–æ–≤–µ—Ä–∫–∞ –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç–∏ –±–æ—Ç–∞...")
    logger.info("=" * 60)
    if not verify_bot_ready():
        logger.error("\n‚ùå –ë–æ—Ç –Ω–µ –≥–æ—Ç–æ–≤ –∫ –∑–∞–ø—É—Å–∫—É. –ò—Å–ø—Ä–∞–≤—å—Ç–µ –æ—à–∏–±–∫–∏ –∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.")
        return
    logger.info("=" * 60 + "\n")

    offset = None
    while True:
        try:
            updates = get_updates(offset)
            for update in updates:
                offset = update["update_id"] + 1
                if "message" in update:
                    handle_message(update["message"])
                elif "callback_query" in update:
                    handle_callback_query(update["callback_query"])
            time.sleep(POLL_INTERVAL)
        except KeyboardInterrupt:
            logger.info("Telegram polling stopped by user")
            break
        except Exception as e:
            logger.error(f"Error in polling loop: {e}")
            time.sleep(POLL_INTERVAL)


def main() -> None:
    try:
        run_polling_loop()
    except Exception as e:
        logger.error(f"Fatal error in Telegram polling: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()

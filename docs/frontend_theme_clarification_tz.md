## ТЗ: обработка clarification_required на фронте

Цель: добавить на клиенте (web/telegram UI) поддержку уточнения тематики, когда бэкенд сигнализирует `clarification_required=True`, чтобы пользователь мог выбрать нужную тему, а затем получить ответ только по выбранной тематике.

---

### 1. API-контракт и формат данных

1.1. Ответ бэкенда `handle_query` уже может возвращать поля:
- `clarification_required: bool` — флаг, что нужен выбор тематики;
- `answer_markdown: str` — текст, объясняющий, что найдено несколько тематик и предлагающий варианты (например, нумерованный список);
- `sources: []` — пустой список;
- `meta` может отсутствовать или быть пустым.

1.2. Для полноценной поддержки выбора на фронте потребуется расширить ответ:
- добавить опциональное поле `clarification_themes: list[dict]`, где каждый элемент:
  - `id: str` — идентификатор темы (`theme_id` из `themes.yaml`);
  - `display_name: str` — человекочитаемое имя (например, «SDK для Android», «АРМ администратора»).

1.3. При обычном «успешном» ответе (без уточнения) контракт не меняется:
- `clarification_required` отсутствует или `False`;
- `clarification_themes` отсутствует или пустой.

---

### 2. Поведение фронтенда

2.1. Проверка флага уточнения
- После получения ответа от API:
  - если `clarification_required` не установлен или `False`:
    - работать как сейчас (показывать ответ и источники).
  - если `clarification_required == True`:
    - **не** считать это ошибкой;
    - не показывать answer как «финальный ответ»;
    - перейти в режим «уточнения тематики».

2.2. Отображение вариантов тем
- Фронт должен:
  - взять список `clarification_themes` (если есть) и отобразить пользователю в виде списка кнопок/вариантов:
    - текст на кнопке — `display_name`;
    - внутренняя идентификация — `id`.
  - если по какой-то причине `clarification_themes` нет, но в `answer_markdown` уже есть пронумерованные варианты:
    - как минимальную реализацию можно просто показать этот текст и попросить пользователя выбрать, написав номер/название (но предпочтителен структурированный список `clarification_themes`).

2.3. Выбор пользователем
- При нажатии на конкретный вариант (пример для web):
  - фронт отправляет новый запрос на тот же endpoint чата, но с дополнительным полем, например:
    - `selected_theme_id: "<theme_id>"`;
  - текст запроса может быть:
    - либо оригинальный вопрос (`message`),
    - либо короткое подтверждение («Тематика: SDK для Android»), но на бэкенде должен быть доступен исходный текст (см. ниже).
- Для Telegram:
  - реализовать inline‑кнопки с callback data, содержащей `theme_id` и, при необходимости, ссылку на исходный запрос.

2.4. Повторный запрос на бэкенд
- Фронт не делает собственную фильтрацию; он лишь:
  - добавляет к запросу `selected_theme_id` (и, при необходимости, `original_message_id`/`original_query`);
  - отправляет его в тот же обработчик (`handle_query` или специализированный endpoint).

---

### 3. Требования к бэкенду для поддержки selected_theme_id (для полноты ТЗ)

3.1. Параметр `selected_theme_id`
- Бэкенд должен поддерживать дополнительное поле (в body запроса или query-параметре):
  - `selected_theme_id: str` — идентификатор темы из `themes.yaml`.
- При наличии этого поля:
  - `route_query` может:
    - либо быть пропущен и использовать только выбранную тему;
    - либо использовать выбранную тему как жёсткий приоритет при маршрутизации.

3.2. Фильтрация и буст
- Для `selected_theme_id`:
  - в `_build_theme_filter` использовать только одну тему без `requires_disambiguation`;
  - `routing_result` формировать так, чтобы `primary_theme == selected_theme_id`, `requires_disambiguation=False`.

3.3. Связь с исходным запросом
- Если фронт не повторно отправляет текст оригинального запроса, а только `selected_theme_id`, бэкенду понадобится:
  - либо хранить последний запрос пользователя в сессии и переиспользовать его;
  - либо получать оба поля:
    - `original_query` — текст исходного вопроса;
    - `selected_theme_id`.

Это решение должно быть согласовано с текущим форматом API чата.

---

### 4. UI/UX требования

- При `clarification_required=True`:
  - явно показать пользователю, что система нашла несколько возможных тематик и предлагает выбор, а не «ошибку»;
  - после выбора темы:
    - либо скрыть экран с уточнением,
    - либо показать историю: «Вы выбрали тему: …», затем финальный ответ.
- Учесть, что:
  - выбор тематики должен быть неблокирующим для других сообщений (каждая сессия/чат — независимы);
  - желательно логировать выбранные тематики (на бэкенде), чтобы позже анализировать качество роутера.

---

### 5. Тестирование на фронте

- Юнит/интеграция:
  - мокнуть ответ API с `clarification_required=True` и несколькими `clarification_themes`;
  - проверить, что:
    - отрисовываются кнопки/элементы для каждой темы;
    - клик по теме приводит к отправке запроса с `selected_theme_id`;
    - после получения финального ответа `clarification_required` больше нет, и ответ отображается нормально.
- E2E:
  - провести сценарий с реальным бэкендом:
    - запрос, заведомо требующий уточнения (например, двусмысленный между SDK и ARM);
    - выбор темы;
    - проверка, что ответ относится только к выбранной тематике, а не смешивает контент.


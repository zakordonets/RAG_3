## Единое ТЗ на рефакторинг поиска: метаданные, бустинг, роутинг, использование тематик

Цель: улучшить качество RAG‑поиска за счёт:
- нормализованных тематических метаданных на уровне индекса;
- конфигурируемого, модульного буста (boosting);
- тематического роутера запросов с внешним источником тематик;
- корректного использования тематик при формировании ответа (фильтрация, структурирование, уточнения).

Предполагается **полная переиндексация** после реализации, миграция существующих данных не требуется.

Реализация делится на четыре этапа:
1. Метаданные (`domain/section/platform/role`) — фундамент.
2. Рефакторинг буста.
3. Роутер + внешний источник тематик.
4. Использование тематик при ответе.

Архитектурно:
- Функция `route_query` вызывается на уровне сервиса поиска **выше** `hybrid_search`.
- В `hybrid_search` передаётся готовый `routing_result` через `context`.
- Бусты по секциям/платформам и тематические бусты должны быть **умеренными** и настраиваемыми в одном конфиге.

Документ построен по принципу multi‑pass (Initial Scan → Simplify → Design → Review): сначала фундамент (метаданные), затем упрощение/выделение буста, затем дизайн роутера и использование тематик.

---

## Этап 1. Нормализация тематик в метаданных

**Цель:** гарантировать, что каждый чанк имеет явную тематику, пригодную для фильтрации и буста.

### 1.1. Схема тематических полей

Ввести / закрепить в метаданные документов следующие поля:

- `domain`: крупный продуктовый домен, например:
  - `chatcenter_user_docs` — пользовательская документация (АРМы);
  - `sdk_docs` — SDK (Android/iOS/Web);
  - `api_docs` — API/swagger;
  - `external_site` — прочие сайты.
- `section`: функциональный раздел внутри домена:
  - для ChatCenter: `agent`, `supervisor`, `admin`, `faq`, `blog`, `integration`, `reporting`, …;
  - для SDK: `sdk` или более детализированные значения (`sdk_getting_started`, `sdk_advanced` и т.п.).
- `platform`: для SDK: `android`, `ios`, `web`, `main`; для остальных — `""` или `null`.
- `role`: логическая роль пользователя (если релевантно): `operator`, `administrator`, `integrator`, `viewer`, …  
  Может использоваться в роутинге и бусте.
- (опционально, но желательно) `page_type`:
  - `overview` / `howto` / `install` / `reference` / `faq` / `changelog` …

### 1.2. Извлечение тематик при индексации

На этапе нормализации источников (Docusaurus, сайты и др.) реализовать маппинг в эти поля:

- Для ChatCenter (Docusaurus):
  - по URL и/или `dir_meta` определять:
    - `domain="chatcenter_user_docs"`;
    - `section` по корню пути:
      - `/docs/agent/…` → `section="agent"`;
      - `/docs/supervisor/…` → `section="supervisor"`;
      - `/docs/admin/…` → `section="admin"`;
      - `/docs/chat-bot/…` → `section="chat-bot"`;  
      - `/docs/api/…` → `section="api"`;
      - `/docs/faq/…` → `section="faq"`;
      - `/blog/…` → `section="blog"`;
    - `role` на основе `section`, например:
      - `agent` → `role="operator"`;
      - `admin` → `role="administrator"`;
      - `supervisor` → `role="supervisor"`;
      - `api` → `role="integrator"`.
- Для SDK (Docusaurus с `android/ios/web/main`):
  - по корню каталога и уже существующим полям `sdk_platform`, `product`:
    - `domain="sdk_docs"`;
    - `section="sdk"` (или более детализированный, если есть необходимость);
    - `platform = sdk_platform` (`android` / `ios` / `web` / `main`);
    - `role="integrator"` (по умолчанию для SDK‑доков).
- Для других источников:
  - определить аналогичный маппинг (минимально — `domain` и `section`).

**Точки интеграции:**
- нормализаторы `ingestion/normalizers/...` (в частности DocusaurusNormalizer);
- адаптеры (`DocusaurusAdapter`, `WebsiteAdapter`) при формировании `RawDoc.meta`.

### 1.3. Протаскивание тематик в Qdrant

Убедиться, что поля `domain`, `section`, `platform`, `role`, `page_type`:

- попадают в `RawDoc.meta`;
- сохраняются в `ParsedDoc.metadata` после нормализации;
- попадают в payload чанка, формируемый `QdrantWriter._create_payload`.

При необходимости:

- укрепить контракт `QdrantWriter._create_payload`, явно указывая, что эти поля должны переноситься без модификации;
- добавить индексы payload по этим полям в Qdrant (через `create_payload_indexes` или аналог).

### 1.4. Минимальные проверки

- Тесты для маппинга:
  - SDK:
    - документ `android/getting-started/installation.md` получает:
      - `domain="sdk_docs"`, `section="sdk"`, `platform="android"`, `role="integrator"`.
  - ChatCenter:
    - документ `/docs/admin/...` получает:
      - `domain="chatcenter_user_docs"`, `section="admin"`, `role="administrator"`.
- Тесты на то, что эти поля присутствуют в payload точки Qdrant после записи.

---

## Этап 2. Рефакторинг буста (boosting)

**Цель:** вынести логику буста из `app/retrieval/retrieval.py` в отдельный модуль и конфигурацию, чтобы:
- ранжировать документы **внутри уже выбранных тематик**;
- избавиться от жёсткого хардкода в коде;
- использовать тематические поля (`domain/section/platform/page_type`) и результат роутера (`routing_result`) как мягкие сигналы.

### 2.1. Архитектурные предпосылки

- `hybrid_search`:
  - больше не должен содержать сложной логики буста; только вызывает отдельный модуль.
  - получает `routing_result` через аргумент `context` (его формирует слой выше, который вызывает `route_query`).
- Буст по `section`/`platform`/темам:
  - должен быть **умеренным** (в диапазоне, условно, 1.0–1.5);
  - коэффициенты калибруются совместно, через один конфиг.

### 2.2. Конфигурация буста

- Создать файл `app/config/boosting.yaml`.
- Примерная структура:

```yaml
page_type_boosts:
  overview: 1.5
  howto: 1.2
  faq: 1.2
  reference: 1.0
  changelog: 0.8

section_boosts:
  sdk: 1.1
  agent: 1.0
  admin: 1.0
  supervisor: 1.0
  api: 1.1

platform_boosts:
  android: 1.2
  ios: 1.2
  web: 1.1
  main: 1.0

url_patterns:
  overview:
    paths: ["/start/", "/overview", "/introduction", "/what-is", "/about"]
    boost: 1.5
  faq:
    paths: ["/faq", "/guide", "/manual", "/help"]
    boost: 1.2
  technical:
    paths: ["/admin/", "/api/", "/sdk/", "/integration"]
    boost: 1.2
  release:
    paths: ["/blog", "/release", "/version", "/changelog"]
    boost: 0.8

title_keywords:
  overview:
    words: ["что такое", "обзор", "введение", "начало работы", "возможности"]
    boost: 1.5
  technical:
    words: ["настройка", "конфигурация", "установка"]
    boost: 1.2

length:
  optimal_min: 1000
  optimal_max: 5000
  optimal_boost: 1.1
  long_boost: 1.1

structure:
  well_structured_markers: ["##", "###", "•", "1.", "2.", "3."]
  example_markers: ["пример", "например", "как", "шаг"]
  well_structured_boost: 1.05
  example_boost: 1.1

source_boosts:
  docs-site: 1.1
  official-docs: 1.1
  main-docs: 1.1

depth_penalty:
  min_depth: 4
  factor: 0.95
```

**Требования:**

- Конфиг может отсутствовать или быть неполным:
  - в таком случае используются дефолтные значения (множитель 1.0).
- Все коэффициенты и паттерны задаются через YAML; никаких «магических чисел» в коде.

### 2.3. Модуль конфигурации буста

- Создать `app/config/boosting_config.py`.
- Функция:

```python
def get_boosting_config() -> BoostingConfig:
    ...
```

**Требования:**

- Один раз загружать YAML при первом вызове, затем кешировать (Single Load).
- При ошибках:
  - логировать предупреждение (`WARNING`/`ERROR`);
  - возвращать конфиг с разумными дефолтами.
- Приводить типы к ожидаемым (`float`/`int`, списки строк) и защищаться от некорректных значений.

### 2.4. Модуль буста

- Создать `app/retrieval/boosting.py`.
- Интерфейс:

```python
def boost_hits(
    hits: list[dict],
    cfg,
    context: dict | None = None,
) -> list[dict]:
    ...

def boost_score(
    base_score: float,
    payload: dict,
    cfg,
    context: dict | None = None,
) -> float:
    ...
```

- `context` может содержать:
  - `routing_result` (результат `route_query`, см. Этап 3);
  - `boosts` / `group_boosts` для обратной совместимости c существующим API (если нужно).

**Поведение:**

- `boost_hits`:
  - для каждого `item` в `hits`:
    - вычисляет `base_score = item.get("rrf_score", item.get("score", 0.0))`;
    - вычисляет `item["boosted_score"] = boost_score(base_score, item.get("payload", {}), cfg, context)`;
  - сортирует `hits` по `boosted_score` по убыванию (или сортировка остаётся в `retrieval.py` — главное, чтобы это было сделано ровно в одном месте).

### 2.5. Правила буста

В `boosting.py` реализовать набор правил (внутренние функции), каждое из которых изменяет `s`:

1. `_apply_page_type_boost`:
   - использует `payload["page_type"]` и `cfg.page_type_boosts`.
2. `_apply_section_platform_boost`:
   - использует `payload["section"]`, `payload["platform"]` / `payload["sdk_platform"]` и `cfg.section_boosts`, `cfg.platform_boosts`.
3. `_apply_theme_boost_from_routing`:
   - использует `context["routing_result"]` (если есть);
   - усиливает документы, чьи `domain/section/platform/role` соответствуют более вероятным темам.
4. `_apply_group_boost`:
   - использует `context["group_boosts"]` и поля `groups_path` / `group_labels` (для совместимости).
5. `_apply_url_pattern_boost`:
   - использует `url` и `cfg.url_patterns` вместо хардкода.
6. `_apply_title_boost`:
   - использует `title` и `cfg.title_keywords`.
7. `_apply_length_boost`:
   - использует `content_length` и `cfg.length`.
8. `_apply_structure_boost`:
   - анализирует `text` и маркеры из `cfg.structure`.
9. `_apply_source_boost`:
   - использует `source` и `cfg.source_boosts`.
10. `_apply_depth_penalty`:
    - использует глубину `url` и `cfg.depth_penalty`.

`boost_score` должен последовательно вызывать эти правила в фиксированном порядке.

### 2.6. Интеграция в `hybrid_search`

- В `app/retrieval/retrieval.py`:
  - Импортировать:

    ```python
    from app.config.boosting_config import get_boosting_config
    from app.retrieval.boosting import boost_hits
    ```

  - После RRF‑слияния (`fused = rrf_fuse(...)`):
    - получить `cfg = get_boosting_config()`;
    - сформировать `context`:

      ```python
      context = {
          "boosts": boosts or {},
          "group_boosts": group_boosts or {},
          "routing_result": routing_result,  # если передан уровнем выше
      }
      ```

    - вызвать `fused = boost_hits(fused, cfg, context=context)`.

  - Удалить старую inline‑функцию `boost_score` и связанную с ней логику.
- Сигнатуру `hybrid_search` не менять (для совместимости).

### 2.7. Тестирование буста

- Юнит‑тесты для `boosting.py`:
  - кейс без конфигурации (все коэффициенты 1.0) — score не меняется;
  - кейс, приближенный к текущему поведению (с конфигом, соответствующим старым `CONFIG.boost_*`);
  - отдельные тесты для секционных/платформенных бустов и влияния `routing_result`.
- Тесты для `boosting_config`:
  - корректный YAML;
  - неполный YAML (используются дефолты);
  - некорректный YAML (лог + дефолты).

---

## Этап 3. Тематический роутер запросов и внешний источник тематик

**Цель:** определить, какие тематики релевантны запросу **до** вызова `hybrid_search`, и сделать настройки тематик управляемыми извне.

### 3.1. Сущность Theme

- Ввести абстракцию `Theme`, описываемую как комбинация:
  - `id: str` — идентификатор темы;
  - `domain: str`;
  - `section: str | None`;
  - `platform: str | None`;
  - `role: str | None`;
  - `display_name: str` — человекочитаемое имя;
  - дополнительные поля (например, описание, приоритет).

Примеры:

- `sdk_android` → `{domain: "sdk_docs", section: "sdk", platform: "android", role: "integrator"}`  
- `user_admin` → `{domain: "chatcenter_user_docs", section: "admin", role: "administrator"}`.

### 3.2. Внешний источник тематик

- Требование: список тематик и их свойства не должны быть жестко зашиты в код.
- Вариант 1 (по умолчанию): YAML‑конфиг, например `app/config/themes.yaml`:
  - раздел `themes`, где задаются все `Theme` (id + поля).
  - конфиг может генерироваться/редактироваться внешними средствами (по результатам индексации, вручную и т.п.).
- Вариант 2 (расширяемость): интерфейс `ThemesProvider`:

  ```python
  class ThemesProvider(Protocol):
      def list_themes(self) -> list[Theme]: ...
      def get_theme(self, theme_id: str) -> Theme | None: ...
  ```

  - Базовая реализация читает `themes.yaml`;
  - в будущем можно заменить на провайдера, читающего из БД/HTTP‑сервиса.

### 3.3. Тематический роутер запросов

- Создать модуль `app/retrieval/theme_router.py`.
- Интерфейс:

```python
class ThemeRoutingResult(TypedDict):
    themes: list[str]           # id тематик, отсортированные по релевантности
    primary_theme: str | None   # наиболее вероятная тематика
    scores: dict[str, float]    # theme_id -> score
    requires_disambiguation: bool  # нужно ли уточнять тематику у пользователя

def route_query(query: str, *, user_metadata: dict | None = None) -> ThemeRoutingResult:
    ...
```

**Требования:**

- `route_query`:
  - загружает список тематик из `ThemesProvider`;
  - использует комбинацию сигналов:
    - простые эвристики (ключевые слова «android», «gradle», «xcode», «оператор», «администратор», «SDK», «АРМ» и т.п.);
    - по необходимости небольшой LLM‑запрос, который возвращает наиболее подходящие темы (по описаниям тематик из внешнего ресурса);
    - пользовательский контекст (`user_metadata`: роль, заранее выбранный продукт и т.п.).
  - возвращает:
    - список кандидатов (`themes`) с оценками;
    - `primary_theme` (если уверенность достаточная);
    - флаг `requires_disambiguation`, если выбор между темами неоднозначен.

### 3.3.1. Режимы роутера (`THEME_ROUTER_MODE`)

- `none` — роутер отключён, поиск идёт без тематических подсказок.
- `heuristic` — локальные эвристики (ключевые слова, роль пользователя, `KEYWORD_MAP`). Значение по умолчанию.
- `llm` — при необходимости спрашиваем LLM; если он ничего не вернул, fallback на heuristics.

`route_query` больше **никогда не блокирует** поиск: даже при `requires_disambiguation=True` мы выполняем хотя бы один проход `hybrid_search`.

### 3.3.2. Soft routing вместо жёстких фильтров

- Фильтр по метаданным (domain/section/platform/role) включается только при очень высокой уверенности:
  - `router="llm"` и `score >= 0.9`;
  - или `router="heuristic"` и разрыв между топ-1 и топ-2 >= 0.35.
- Во всех остальных случаях поиск идёт по всему индексу, а тематика используется как мягкий сигнал:
  - документы помечаются `theme_label` через `infer_theme_label`;
  - перед rerank'ом добавляется небольшой буст (+0.08 для `primary_theme`, +0.04 для следующей темы);
  - rerank получает уже подсказанный список, но может переупорядочить его по релевантности.
- Если тематика неуверенная, можно (опционально) попросить пользователя уточнить тему **после** того, как посмотрели на реальные top-docs.

### 3.5. Генерация тематик по результатам индексации

- Реализовать вспомогательный скрипт/утилиту, который:
  - обходит коллекцию (или метаданные до записи);
  - собирает уникальные комбинации `domain/section/platform/role`;
  - формирует черновой `themes.yaml` со списком потенциальных тематик;
  - может запускаться вручную или по расписанию.

#### 3.5.1. Аналитика по тематикам

**Задачи:**

- Выполнить «обратную инженерию» фактически используемых тематик по уже проиндексированным данным.
- Сгенерировать:
  - статистику по комбинациям `domain/section/platform/role`;
  - черновой список предложений для `themes.yaml` (какие тематики явно используются, какие отсутствуют).

**Логика (можно реализовать любым удобным способoм — ноутбук, ad-hoc скрипт и т.п.):**

1. Подключиться к Qdrant (`CONFIG.qdrant_url/api_key/collection`) и обойти коллекцию (scroll).
2. Для каждого документа/чанка извлечь `domain/section/platform/role/page_type/title/url`.
3. Построить агрегаты по комбинациям, сохранив `doc_count` и несколько примеров заголовков.
4. На основе агрегатов подготовить черновой YAML (аналогично примеру ниже), вручную сравнить его с `themes.yaml` и решить:
   - какие темы уже покрыты и описаны корректно;
   - какие темы нужно добавить/уточнить;
   - какие комбинации следует игнорировать (слишком мало документов).

```yaml
themes:
  chatcenter_user_docs_supervisor:
    display_name: "АРМ супервайзера (auto)"
    domain: "chatcenter_user_docs"
    section: "supervisor"
    role: "supervisor"
    stats:
      doc_count: 123
      sample_docs:
        - title: "Учет оценок в отчетности и KPI агента"
          url: "https://docs-chatcenter.edna.ru/..."
        - title: "Просмотр полной переписки с клиентом"
          url: "https://docs-chatcenter.edna.ru/..."
```

> Пример выше — шаблон для внутренних проверок; готовый YAML в коде не используется.

**Дополнительные эксперименты:**

- При желании можно собрать датасет (`text`, `theme_id`) с заголовками/фрагментами документов, чтобы тестировать свои идеи по обучению классификатора.
- Этот датасет пригоден только для аналитики; основная система работает без него.

---

## Этап 4. Использование тематик при ответе (фильтрация, структурирование, уточнения)

**Цель:** использовать тематики в трёх местах:
- при выборе документов (фильтрация/soft‑boost);
- при формировании текста ответа (структурирование по темам);
- при работе с неоднозначными запросами (уточняющие вопросы).

### 4.1. Фильтрация по основной тематике

- Если уверенность высокая (LLM ≥ 0.9 или heuristics с большим разрывом), строим `Filter(must=[domain, section, platform, role])`.
- Иначе `metadata_filter=None`, поиск обрабатывает весь индекс.

### 4.2. Мягкий тематический буст

- `routing_result` передаётся в `_apply_theme_boost`:
  - `primary_theme` → +0.08 к `score`;
  - темы из `themes[1:3]` → +0.04;
  - остальные документы не штрафуются.
- После буста список сортируется и уходит в rerank.
- Таким образом, даже если вопрос затрагивает несколько тематик, обе остаются в выдаче, но более релевантная идёт выше.

### 4.3. Уточняющие вопросы

- Поиск всегда выполняется.
- Если `requires_disambiguation=True` и top‑N документов после rerank делятся на несколько явных тематик, можно (опционально) показать уточняющее сообщение пользователю, опираясь на реальные `theme_label` найденных документов.
- В перспективе (если UI поддерживает такой сценарий) после выбора темы можно повторно вызвать `hybrid_search` уже с явным фильтром по выбранной тематике.

### 4.4. Структурирование мультитематичных ответов

- Когда итоговый поиск выполнялся по нескольким темам (по бизнес‑решению):
  - при сборе контекста для LLM:
    - явно помечать, к какой теме относится каждый чанк, например:

      ```text
      [THEME: sdk_android]
      ...текст чанка...

      [THEME: user_admin]
      ...текст чанка...
      ```

  - в системном промпте для LLM прописать правило:
    - «Если в контексте есть фрагменты с разными THEME, формируй ответ отдельными разделами по каждой THEME, с понятными заголовками («Для SDK Android», «Для АРМ администратора» и т.п.). Не смешивай инструкции.»

Это делает мультитематичные ответы понятными и предсказуемыми.

### 4.5. Связь с модулем буста

- Модуль буста (`boosting.py`) должен использовать `routing_result` **только для мягкого тематического усиления**:
  - секционные/платформенные и тематические коэффициенты должны быть небольшими и настраиваться совместно в `boosting.yaml`;
  - вся фильтрация по темам выполняется на уровне сервиса, который вызывает `hybrid_search`, а не внутри буста.

### 4.6. Тестирование поведения на уровне ответа

- Тест‑кейсы/сценарии (можно как интеграционные тесты или ручные сценарии с логированием):
  - запрос явно про Android SDK → роутер выбирает `sdk_android`, выдача не содержит ARM‑доки, ответ сосредоточен на Android;
  - запрос про «обязательные теги» с двусмысленностью → роутер выдаёт несколько тем, `requires_disambiguation=True`, пользователь выбирает тему, затем ответ формируется только по ней;
  - запрос явно про две роли → роутер отдаёт две темы, поиск идёт по обеим, ответ структурирован по темам.

---

## Соответствие архитектурным принципам

- **SLON/KISS**:
  - разделение на лёгкие, независимые компоненты:
    - нормализация метаданных;
    - модуль буста;
    - тематический роутер;
    - слой формирования ответа;
  - чёткие границы ответственности и минимальные пересечения.
- **Multi‑pass design (Initial Scan → Simplify → Design → Review)**:
  - Этап 1 — собираем и приводим к единому виду данные (Initial Scan).
  - Этап 2 — упрощаем и выносим сложный boosting в отдельный конфиг/модуль (Simplify).
  - Этап 3 — проектируем роутер и внешние тематики (Design).
  - Этап 4 — проверяем и адаптируем поведение на уровне ответа (Review).



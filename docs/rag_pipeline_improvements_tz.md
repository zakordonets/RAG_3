## ТЗ: точечные улучшения RAG-пайплайна

Цель: без изменения внешнего API аккуратно доработать текущий RAG-пайплайн, чтобы упростить сопровождение, улучшить наблюдаемость и сделать поведение более предсказуемым.

Ниже задачи сформулированы как отдельные блоки, которые можно брать по одному.

---

### 1. Оркестратор и логирование

**Файлы:** `app/orchestration/orchestrator.py`

**Задачи:**

1.1. Разделить метрики времени по этапам:
- Ввести отдельные таймеры для:
  - query processing,
  - routing,
  - embeddings,
  - hybrid search,
  - rerank,
  - context optimization,
  - LLM generation.
- Обновить логирование: в логах и метриках должны явно фигурировать времена каждого этапа, а не только «общий Rerank in Xs».

1.2. Уточнить лог rerank:
- Сейчас лог `Rerank in {time.time() - start:.2f}s` считает время от начала запроса. Заменить на время только rerank-этапа (от `rerank_start` до окончания rerank).

1.3. Проверить и, при необходимости, привести к единому стилю сообщения об ошибках:
- Внутренние логи должны быть на русском языке;
- Убедиться, что клиентские сообщения об ошибках (в ответе API) согласованы по стилю и содержанию.

---

### 2. Тематический роутер и бустинг

**Файлы:** `app/retrieval/theme_router.py`, `app/orchestration/orchestrator.py`, `app/retrieval/retrieval.py` (контекст для boost).

**Задачи:**

2.1. Централизовать тематический буст:
- Сейчас тематика влияет на скор двумя способами:
  - через `boost_hits` (куда уже передаётся `routing_result`),
  - через `_apply_theme_boost` в оркестраторе (пост-обработка кандидатов перед rerank).
- Требуется:
  - определиться, где именно жить тематическому бусту (либо только в `boost_hits`, либо оставить минимальный буст в оркестраторе);
  - реализовать единый источник коэффициентов (например, через `boosting.yaml`), чтобы не было жёстких чисел +0.08/+0.04 в коде.

2.2. Более явные пороги уверенности для `_is_theme_filter_allowed`:
- Вынести пороги (LLM ≥ 0.9, разрыв heuristic ≥ 0.35) в константы или конфиг (`CONFIG`), чтобы их можно было настраивать и легче читать в коде.
- Обновить доки (при необходимости) под новые места хранения порогов.

2.3. Улучшить KEYWORD_MAP на основе реальных запросов (опционально):
- Собрать список проблемных запросов (например, про теги, CSI, отчёты);
- Точечно добавить/изменить ключевые слова в `KEYWORD_MAP`, не превращая его в огромный словарь;
- Добавить короткий комментарий в коде, что KEYWORD_MAP — эвристика и должен обновляться только по подтверждённым кейсам.

---

### 3. Embeddings-сервис: структуризация и cleanup

**Файл:** `app/services/core/embeddings.py`

**Задачи:**

3.1. Явно разделить публичный и внутренний API:
- Описать (в docstring или вверху файла), какие функции являются «официальным» интерфейсом для других модулей:
  - online: `embed_unified`, `embed_dense_optimized`, `embed_sparse_optimized`;
  - offline/ingestion: `embed_batch_optimized` и т.п.
- Пометить вспомогательные функции как внутренние (например, в комментарии или через `_` в имени, если где‑то ещё не соблюдено).

3.2. Проверить на неиспользуемые функции:
- Найти функции, которые не используются нигде в кодовой базе (кроме, возможно, старых тестов/примеров);
- Если такие есть:
  - либо удалить их,
  - либо перенести в отдельный «legacy/experimental» модуль, чтобы не мешали основному пути.

3.3. Документировать поведение `ensure_embedding_backends_ready`:
- Кратко описать в коде/доках:
  - что стратегия backend выбирается один раз на процесс;
  - при каких условиях возможен `force=True` (если вы планируете его использовать).

---

### 4. Retrieval и Rerank

**Файлы:** `app/retrieval/retrieval.py`, `app/retrieval/rerank.py`

**Задачи:**

4.1. Проверка k_dense/k_sparse на соответствие конфигу:
- Добавить краткий комментарий в `hybrid_search` о том, почему выбрано `k_dense = k_sparse = 2*k`, и возможно ли сделать это параметром (через CONFIG), если понадобится.

4.2. Rerank: логирование и fallback:
- В `rerank` при падении в single-batch fallback уже есть логирование. Проверить, что:
  - при полном фейле rerank (когда даже fallback падает) лог содержит достаточно информации (размер входных данных, тип модели);
  - оркестратор в этом случае корректно возвращает "best-effort" (первые `top_n` без перерасчёта score). Сейчас это реализовано, но стоит явно зафиксировать это поведение в docstring или комментарии.

---

### 5. Оценка влияния роутера и оптимизатора контекста (проекты для будущих итераций)

**Файлы:** тесты / скрипты (новые), интеграция с уже существующим quality layer.

**Задачи (опционально, как отдельные задачи):**

5.1. Простая offline‑оценка роутера:
- Собрать небольшой набор вопросов с ожидаемыми темами (`theme_id` или хотя бы `domain/section`).
- Написать тест/скрипт, который:
  - прогоняет эти вопросы через `route_query` в режимах `none`, `heuristic`, `llm` (если подключён);
  - меряет долю совпадений `primary_theme` с ожиданием.

5.2. Оценка влияния тематического буста на retrieval:
- Для выбранного набора запросов:
  - отключить `_apply_theme_boost` и тематический компонент в boosting (если он туда будет вынесен);
  - включить их обратно;
  - сравнить метрики типа Recall@k / долю релевантных документов в top‑k.

5.3. Оценка контекст‑оптимизатора:
- Для нескольких типов запросов (simple/medium/complex/list):
  - залогировать, сколько документов и сколько токенов попадает в LLM после оптимизации;
  - проверить вручную/через RAGAS, нет ли систематических случаев, когда оптимизатор «обрезает» самый важный документ.

---

### 6. Документация и консистентность

**Файлы:** `docs/architecture.md`, `docs/topic_routing_tz.md`, возможно README.

**Задачи:**

6.1. Поддерживать doc ↔ code в актуальном состоянии:
- После внедрения пунктов 2.1/3.2/4.1 обновить соответствующие разделы в архитектурной документации (особенно про thematic boost и retrieval pipeline).

6.2. Явно зафиксировать в документации «принцип мягкого роутинга»:
- Вынести короткий тезис вроде: «Theme Router никогда не блокирует поиск; фильтрация по темам включается только при высокой уверенности. В остальных случаях используется soft‑boost».

---

Этот файл задуман как «backlog улучшений» для Codex/разработчиков. Задачи независимы: их можно брать по одной, не ломая текущий рабочий пайплайн.
